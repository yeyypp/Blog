public class Main {
    /**
     * 应用进程要进行网络链接时会通过socket系统调用，请求操作系统为其创建一个套接字，就是操作系统把网络通信的资源分配给应用进程
     * 资源的总和叫套接字描述符socket descriptor
     *
     * 服务端调用socket函数，bind绑定端口，listen监听
     * 客户端调用socket函数，connect函数连接，发送syn，connect阻塞
     * 服务端收到请求后，调用accept函数，返回syn ack，accept阻塞
     * 客户端收到后，connect返回，发送ack
     * 服务端收到后accept返回，连接建立
     */

    /**
     * 监听到了一个客户的连接请求。管理客户连接请求的任务是由操作系统来完成的。操作系统把这些连接请求存储在一个先进先出的队列中。
     * 许多操作系统限定了队列的最大长度，一般为50。当队列中的连接请求达到了队列的最大容量时，服务器进程所在的主机会拒绝新的连接请求。
     * 只有当服务器进程通过ServerSocket的accept()方法从队列中取出连接请求，使队列腾出空位时，队列才能继续加入新的连接请求。
     *
     * ServerSocket的accept()方法从连接请求队列中取出一个客户的连接请求，然后创建与客户连接的Socket对象，并将它返回。
     * 如果队列中没有连接请求，accept()方法就会一直等待，直到接收到了连接请求才返回。
     *
     * SO_TIMEOUT表示ServerSocket的accept()方法等待客户连接的超时时间,超时会抛出sockettimeoutexception
     *SO_REUSEADDR 指在状态处于time wait 重启服务器，重新绑定相同的端口
     */

    /**
     * 直接io，缓冲io
     * 缓冲io
     * 在内核中维护一个缓冲区，无论用户读取的数据多小，都从磁盘中加载一段数据到缓冲区中，下次可以直接从缓冲区中读取
     * 可以减少磁盘读取的次数
     *
     *  1.用户调用read方法
     *
     * 2. 调用系统调用，触发中断，进程从用户态进入内核态
     *
     * 3. 从硬盘中读取数据并复制到kernel缓冲区
     *
     * 4. 将数据从kernel缓存区复制到用户提供的byte数组中
     *
     * 5. 进程从内核态返回到用户态
     *
     * 直接io
     * 从磁盘直接读入数据
     */

    /**
     * 当直接使用inputstream.close时socket也会关闭
     * 用shutinputstram关闭流
     */

    /**
     * 传统bio
     * 一个线程负责一个连接，采用线程池，复用线程
     * 但线程之间的切换对于操作系统来说是昂贵的，因为需要保存现在线程的状态，再切换到另一个线程
     *
     * 代理 代理的对象是客户端 反向代理 代理的对象是服务器
     */
}