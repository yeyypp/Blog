# Java
## Collection
- HashMap
    
    - 1.7
        
        - 实现方式：数组加链表，冲突解决方式为链表法
        - capacity:当前数组容量，扩容大小为当前两倍
        - loadFactor: 负载因子 0.75
        - threshold: 阈值 capacity * loadFactor
        - 非线程安全
        - key value 可以为null
        
    - 1.8
        
        - 实现方式：数组加链表加红黑树
        - 当链表数据为8时转换为红黑树，获取元素时间logN
        - AVL数是严格平衡的，查找更快，但插入时需要消耗过多时间，红黑树在添加，删除，
        查找方面好于AVL数
        - hash = hashcode ^ hashcode >>> 16
    均为线程不安全
    
- ConcurrentHashMap
    
    - 1.7 采用分段锁，一个segment数组，每一个元素是一个链表数组
    - 1.8 采用数组加链表加红黑树
    - 在扩容时，判断sizeCtl是否小于1来确定是否有其他线程，当大于0时会尝试用CAS方法更新
    - 通过CAS 和 volatile 保证安全
    
- ArrayList LinkedList
    
    - ArrayList底层实现为数组，增删慢，获取元素的时间快，扩容时每次变为原数组1.5倍
    - LinkedList 底层为链表实现
- 基本类型 包装类型
    - 基本类型初始值为默认值，包装类型为null
- String StringBuffer StringBuilder
    - 只有StringBuffer是线程安全的
- 封装继承多态
    - 封装 把一段逻辑概念抽象出来，做到相对独立。比如操作系统，隐藏了具体的对磁盘的操作
    - 继承 使代码复用
    - 多态 一组对象表达同一个概念，但展现不同的行为
- 接口 抽象类
    - 接口 是对类的行为进行约束，可以要求不同的类具有相同的行为
    - 抽象类 是为了代码复用，继承的类可以有自己的方法
- 反射
    - 在运行时获得，修改类或者方法的信息
- synchronized
    - 修饰
        - 修饰实例方法：锁住的的是调用方法的对象
        - 修饰代码块：锁住的是代码块中的参数
        - 修饰静态方法：锁住的是当前类的class对象
    - 实现
        - 通过monitor 实现，而monitor会通过操作系统 mutex lock实现，意味着每次尝试
        获取琐时，都会切换到内核态，消耗过大
    - 优化
        - 偏向锁：锁长时间被同一线程访问，不用获取
        - 轻量级：在偏向锁时，有其他线程尝试获取锁，会通过CAS自旋，尝试获取
        - 重量级锁：当自旋一定次数，或者又有新的线程尝试，此时升级为重量级，等待的锁会进入阻塞
    - 锁消除
        - 在编译时，检测到共享数据不会出现竞争，就会执行锁消除
    - 锁粗化
        - 一系列操作都对某个对象重复加锁，则会粗化
- ReenTrantLock
    - 与synchronized相比
        - 可实现公平锁，syn是非公平
        - 需要主动释放，syn不需要
    
    
        