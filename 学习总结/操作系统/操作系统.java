public class Main {
    /**
     * 先通过bios加载bootloader到内存中，再通过bootloader把操作系统加载到内存中
     *
     * 系统调用
     * 应用程序主动向操作系统发出服务请求
     *
     * 异常
     * 来自应用程序意想不到的行为
     *
     * 中断
     * 来源于外设，来自不同设备的计时器及网络
     *
     * 中断时
     * 硬件设置中断标记
     * 软件保存被打断的执行现场
     * 根据中断号，完成相应操作，处理完后清楚中断标记，恢复之前中断的程序
     *
     * 异常时
     * 会得到一个异常编号
     * cpu保存异常现场
     * 操作系统杀死产生异常的指令，或者重新执行
     * 恢复现场
     *
     * cpu将指令分为特权指令，非特权指令，应用程序只能执行不会造成灾难的指令
     * 进程执行自己的代码时称为用户态
     * 进程调用系统调用，进入内核态，会切换堆栈，使用当前进程的内核栈，操作系统会完成具体的服务
     *
     */

    /**
     * 虚拟内存
     * 把常用的放在内存上，不常用的放在硬盘上
     */

    /**
     * 死锁：
     * 是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象
     *
     * 产生原因
     * 系统资源不足
     * 进程运行顺序不合适
     * 资源分配不当
     *
     * 死锁产生的必要条件
     * 互斥 一个资源每次只能被一个进程使用
     * 请求与保持 进程因请求资源而阻塞时不会释放已拥有的资源
     * 不剥夺 进程已获得的资源，在进程执行完前不能强制占有
     * 循环等待 若干进程之间形成一种循环等待的关系
     *
     * 死锁的预防
     * 只要打破死锁的必要条件，严格预防死锁出现
     * 互斥资源不互斥
     * 持有全部资源，再执行
     *
     * 避免
     * 系统对进程的请求进行检查决定是否分配资源，若分配后，可能发生死锁，则不分配
     *
     * 死锁的解除
     * 当发现出现死锁，从其他进程抢占资源，分配给死锁进程
     * 终止死锁进程
     *
     *
     * 临界区：
     * 指一个访问共用资源的一个片段，在任意时刻指允许一个线程进入
     * 当一个进程进入临界区后，其他要进入的进程必须等待，若进程不能进入临界区，应让出cpu，避免出现忙等
     *
     * 互斥量与临界区相似
     * 只有持有互斥量的线程才拥有访问资源的权限
     *
     * 信号量是一个允许同时多个线程访问共享资源的方法
     *
     *
     * 进程：
     * 是一个程序在一段数据集合上动态执行的过程，是资源分配的基本单位
     *
     * 线程：
     * 是进程中的一条执行流程，一个进程可以有多个线程，线程间共享进程的所有资源，线程有自己的堆栈和局部变量
     *
     * 一个程序可以包含多个进程，一个进程只能有一个程序
     *
     * 进程间通讯：
     * 管道 消息队列 信号量 共享内存
     * 管道
     * 管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道。
     * 只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程);
     *
     * 消息队列
     *
     * */

    /**
     * 一个物理内存被分为两个空间，内核空间和用户空间
     * 防止用户直接访问操作系统内存，产生错误
     * 用户需要经过系统调用，访问外部数据，一次系统调用会涉及到两个空间的切换
     *
     *
     * 虚拟存储
     * 就是内存中存储需要的数据，剩下的数据存放在磁盘上，需要的时候再放到内存中
     */

    /**
     *
     */
}