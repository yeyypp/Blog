public class Main {
    /**
     * 什么是子网
     *
     */

    /**
     * 什么是socket
     * socket是一种接口，位于应用层与传输层之间，封装了传输层tpc/ip的操作，让应用直接调用socket来完成通信
     */

    /**
     * 为什么http是无状态，如何理解
     * 每一次客户端的请求，对浏览器来说都是一次新的请求，不会记录之前的信息
     * 通过存储一定的信息在浏览器中cookie，在每次请求中，携带这个cookie，提交给服务器，由服务器判断
     * 缺点：可以恶意修改cookie，每次提交的数据过大
     * 通过session，客户端第一次请求时，将一个sessionid存在浏览器cookie中，每次提交请求，只需提交这个id，服务器存储相应的会话信息
     * 如果禁用cookie，可以用url重写，将id写在url后。
     *
     * 为什么说udp是无连接
     * 相对tcp来说，udp发送数据是直接把封装好的数据发送，而tcp会先建立可靠连接，确认双方均已准备好，再开始发送数据
     *
     * 使用udp的原因
     * 因为有些技术比如视频直播需要低延迟，并可接受一定数据丢失，这就需要udp协议
     *
     * tcp udp
     * tcp是面向连接的，可靠传输，传输速度慢，
     * udp是无连接的，不可靠传输，速度快
     *
     * 为什么tcp是可靠的
     * 通过三次握手，保证连接是可靠的。
     * 通过校验和检查数据是否有误
     * 通过序列号对接收到的数据排序，去重。通过确认号，告诉发送方收到了哪些数据
     * 通过超时重传，保证数据发送，发送方发出数据后等待接收方的ask报文，若一段时间没有得到，则从新发送数据
     * 通过流量控制，在接收方来不及处理数据时，降低发送数据的速度，通过控制滑动窗口大小，进行流量控制
     * 在刚开始发送数据时通过拥塞控制，避免丢包，慢启动机制，在开始发送数据时，发送少量的数据了解网络情况
     *
     * tcp 快速重传
     * 当一段时间没有收到对方的ack，就会发生重传
     * 还有一种重传ack的时机，快速重传
     * tcp采用累计确认机制，当收到的报文序号比期望的大时，会重新发送最近一次确认的ack，当另一方连续收到三个同样的ack时，就知道丢包了
     *
     *
     * 三次握手的过程
     * 假设现在客户端A，服务器为B
     * A带有SYN标志的及序号x数据包给服务端
     * B发送带有syn/ack标志位，加ack确认号x + 1加初始序列号y到A
     * A收到发送带有ack的数据包ack y + 1确认号及序列号 x + 1
     * 此时完成三次挥手
     *
     * 为什么需要三次
     * 因为当两次时，只能保证a发送数据到B是可靠的，B到A不行，三次握手是保证连接可靠的最低次数，当A发送ack确认收到数据
     * 到B时，此时保证连接可靠
     *
     *四次挥手
     * A发送报文包含FIN = 1 及序列号x 表示A不会再发送数据，但还可以接受数据
     * B 发送ack确认号x + 1表示收到，但可能此时B还有数据需要发送
     * 当没有数据需要发送时B，发送Fin = 1 ACk = 1 序列号y
     * 当A收到后发送确认号y + 1，B收到后关闭链接
     * 此时A等待两个最大段生命周期，若没有收到ack，则关闭连接
     *
     * time wait表示主动关闭 close wait 表示被动关闭
     *
     * 流量控制
     * 通过滑动窗口，控制发送的数据，根据返回的窗口大小，调整发送窗口
     *
     * 拥塞控制
     * 1慢开始，拥塞避免
     * 发送方维持一个拥塞窗口，大小取决于网络拥塞程度，
     * 慢开始就是在开始时逐步增大拥塞窗口，窗口大小为一个最大报文段mss的值，收到一个确认，拥塞窗口加倍
     * 而拥塞避免是指每收到一个确认，窗口大小加1，而不是加倍
     *
     * 2.快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。
     * 发送方收到三个重复确认后，说明产生了丢包，就会立即发送丢失的数据
     *
     * 快恢复
     * 减少拥塞窗口，并执行拥塞避免算法
     *
     *
     * http
     * get post 区别
     * 与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！
     * 后退，刷新时无害	数据会被重新提交（浏览器应该告知用户数据会被重新提交）
     *
     *
     *
     * http状态吗
     * 1xx 消息
     * 100 服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。
     * 2xx 成功
     * 200 OK 请求成功（其后是对GET和POST请求的应答文档。）
     * 3xx 重定向
     * 304 Not Modified 未修改的文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。
     * 4xx: 客户端错误
     * 400 Bad Request 服务器未能理解请求。
     * 404 Not Found 服务器无法找到被请求的页面。
     * 5xx: 服务器错误
     * 500 Internal Server Error 请求未完成。服务器遇到不可预知的情况。
     *
     * osi七层模型
     * 应用层 http ftp
     * 表示
     * 会话
     * 传输层tcp udp
     * 网络ip
     * 数据链路
     * 物理
     *
     *
     * 浏览器输入网址发生什么
     * 1.浏览器首先去找本地的hosts文件，检查在该文件中是否有相应的域名、IP对应关系，如果有，则向其IP地址发送请求，如果没有，再去找DNS服务器。
     *
     * 2.DNS返回具体的ip地址，客户端根据IP地址向服务器建立连接，进行三次握手。
     * 首先A发送带有标志位syn，初始序列号为x的数据包到B
     * B收到后，发送带有syn/ack标志位，ack号为x + 1， 以及初始序列号y到A
     * A收到后返回带有ack标志位的数据包，确认号y + 1
     *
     * 3.客户端发送http请求到服务器，服务器处理请求并返回一个响应。
     *
     * 4.数据发送完毕后，进行四次挥手关闭连接
     * 一般有客户端发起
     * A发送带有fin = 1，序列号x的数据包，此时表A没有要发送的数据了
     * 服务器B收到后，发送带有ack标志位为1，以及确认号x + 1，还有序列号y到A，表示收到，
     * 当B处理完数据后，发送fin = 1 ack = 1 ack号为x + 1的数据到A客户端
     * A收到后发送ack确认号，并等待2MSL（Maximum Segment Lifetime）的时间，为了保证B确实收到确认
     * B收到A的确认后立即进入closed状态，关闭了连接
     *
     * 长连接不断开。适用于数据库
     *
     * 5.浏览器解析html css文件，进行渲染，最后将页面展示出来。
     *
     */
}