public class Main {
    /**
     * 线程的启动方式
     * 继承thread类
     * 实现runnable接口
     * 通过callable，futuretask实现
     * 实现接口，还可以继承别的类，更加灵活
     *
     * 使用synchronized ， voliate， ReenTrentLock
     * 1.synchronized有三种使用方式
     * 第一种修饰普通方法前，锁住的是调用这个方法的对象
     *      修饰类静态方法前，锁住的是这个类的对象
     *      修饰代码块，加在指定对象前，锁住括号里的对象
     *
     * 2.voliate
     * 用voliate修饰的共享变量，可以保证该操作的内存可见性
     * 禁止指令重排序
     *
     * 线程a修改boolean变量时，并不会马上把他拷贝回主内存，当线程b使用此变量时，可能还是修改前的
     * 经过修饰的变量，修改后会立即刷入主存，并使其他线程工作内存中的拷贝的变量无效，再使用时会重新从主存中读取
     *
     * 3.通过ReenTrantLock，与syn类似，不同的是需要自己释放获得的锁。
     * 与syn异同
     * 1.他们都是可重入锁
     * 2.reentrantlock可以是公平锁
     *
     *
     * 无锁 偏向锁，轻量级锁，重量级锁
     * 无锁：不锁住资源，多个线程只有
     *
     * synchronized锁优化
     * 偏向锁
     * 线程第一次获取对象的锁的时候，会将此锁改为偏向锁
     * 不需要额外的加锁解锁
     * 当有另一个线程争夺该锁时，会撤销偏向锁，当另一个线程进入后会升级为轻量级
     *
     * 轻量锁
     * 当有某一个线程竞争锁时，会等待该锁，而不是阻塞，但会消耗cpu做无用功
     *当多个线程同时竞争时，会升级成重量级锁
     *
     * 重量级锁
     * 此时同时竞争的线程就会阻塞，虽然不会消耗cpu，但阻塞，唤醒线程需要从用户态转换到内核态，耗费大量资源
     *
     * 悲观所 认为自己在使用数据时，一定会有别的线程更新数据，所以必须先枷锁
     * 乐观锁 认为在使用数据时，不会有别的线程来更新，所以不用加锁，但会在修改数据时，进行判断，是否数据被更新过。
     */

    /**
     * synchronized原理
     * 对象头
     * mark word 存储对象的一些信息，根据锁标志位的变化而变化
     * klass point 指向类元数据的指针，jvm通过这个判断他是哪个类
     *
     * synchronized原理
     * 每个对象有一个monitor与之关联，当一个monitor被线程持有后，便处于锁定状态
     * 使用syn后会在同步的代码块前加monitorenter 后加monitorexit
     *
     * synchronized与Lock锁的比较
     * 锁的获取与释放
     * synchronized是Java语言内置的实现，使用简单，无须关注锁的释放与获取，都是JVM自动管理。
     *
     * Lock相关的锁，则需要手动获取与释放，稍有不慎，忘记释放锁或者程序处理异常导致锁没有释放，
     * 则会造成死锁。所以，通常unLock()操作都要在finally语句块中进行释放锁操作。但是，由于锁的释放与获取都由程序把控，能够实现更灵活的锁获取与释放。
     *
     * Lock锁可以非阻塞、响应中断、响应超时
     * 1.使用Lock接口可以非阻塞地获取锁，具体API是tryLock()和tryLock(long time, TimeUnit unit)。
     *
     * 2.使用Lock接口可以响应中断和超时：synchronized一旦尝试获取锁，就会一直等待下去，直到获取锁；
     * 但是Lock接口可以响应中断或者超时。具体API是lockInterruptibly()和tryLock(long time, TimeUnit unit)。
     *
     * Lock锁提供了更丰富的锁
     * Lock接口提供了更丰富的锁语义：Lock接口及其实现类，实现了读写锁、公平锁与非公平锁等，
     * 读写锁：ReadWriteLock；公平锁与非公平锁：以ReentrantLock为例，只要构造函数传入true，就可以使用公平锁，默认是非公平锁。synchronized是支持重入的非公平锁。
     *
     * volatile原理
     *
     * Threadlocal
     *
     * JUC包
     */
}