public class Main {
    /**
     * 需要先import java.util.Scanner;
     * Scanner in = new Sanner(System.in);
     * 1.当in.next()后需要用nextLIne时，先用一个in.nextLine吃掉空格
     * 2.当需要循环判断in.next的值时，先用String s = in.next，再判断 if (s.equals.....)
     * 避免in.next吃掉值
     *
     * 在有多组测试用例时，先while(in.hasNext())在在里边写代码
     */

    /**
     * 常用方法
     * int 转String Integer.toString();
     * String 转int Integer.parseInt();
     * 数组调转
     * StringBuilder sb = new StringBuilder(s);
     * sb.reverse().toString();
     * Integer.parseInt(sb........
     * 保留小数用float
     */

    /**
     * 约瑟夫环
     * n个数，删掉第m个，即每隔m - 1个
     * 求最后的数的坐标
     * 第一轮出列（m - 1）% n的人
     * 此时（m + i）% n对应n - 1中序号为i的人
     *
     * f(N,M) = (f(N - 1, M) + M) % N;
     *
     */

    //array sort
    Arrays.sort();

    //quick sort

    public void quick(int[] nums) {
        QuickSort(nums,0, nums.length - 1);
    }
    public void QuickSort(int[] nums, int low, int high) {
        if (low > high) {
            return;
        }
        int pivot = partion(nums, low, high);
        QuickSort(nums, low, pivot - 1);
        QuickSort(nums, pivot + 1, high);

    }

    public int partion(int[] nums, int low, int high) {
        int key = nums[low];
        while (low < high) {
            while (low < high && nums[high] >= key) {
                high--;
            }
            nums[low] = nums[high];
            while (low < high && nums[low] <= key) {
                low++;
            }
            nums[high] = nums[low];
        }
        nums[low] = key;
        return low;
    }

    //二分,一般是先Arrays.sort后再二分
    public int binarySearch(int[] nums, int key, int start, int end) {
        if (start > end) {
            return -1;
        }
        int mid = start + (end - start) / 2;
        if (nums[mid] == key) {
            return mid;
        } else if (nums[mid] < key) {
            return binarySearch(nums, key, mid + 1, end);
        }
        return binarySearch(nums, key, start, mid - 1);
    }

    public int binarySearch(int[] nums, int key) {
        int start = 0;
        int end = nums.length - 1;

        while (start < end) {
            int mid = start + (end - start) / 2;
            if (nums[mid] == key) {
                return mid;
            }
            if (nums[mid] < key) {
                start = mid + 1;
            }
            if (nums[mid] > key) {
                end = mid - 1;
            }
        }
        return -1;
    }

    //顺序输出数组
    int i = 0;
    i = (i + 1) % nums.length;

    //倒转数组

    for (int i = 0; i < nums.length / 2; i++) {
        tem = nums[i];
        nums[i] = nums[nums.length - 1 - i];
        nums[nums.length - 1 - i] = tem;
    }



}