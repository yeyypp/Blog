public class Main {
    /**
     * synchronize：
     * 保证方法或代码块在同一时刻只有一个操作可以进入临界区，同时还可以保证共享变量的可见性，解决重排序
     * 三种使用方式：
     * 1.修饰实例方法：锁住的的是调用方法的对象
     * 2.修饰代码块：锁住的是代码块中的参数
     * 3.修饰静态方法：锁住的是当前类的class对象
     *
     * 同步代码块底层实现原理：
     * 是在代码块的前后插入monitorenter和monitorexit来实现同步，每个对象都会有一个监视器，通过上边两个指令来获取监视器，当
     * 一个线程获取了监视器，其他线程就不能获取，此时监视器进入次数为1，若重入，则进入次数加1
     *
     * 针对synchronize的三种锁的状态
     * 偏向锁 -> 轻量级锁 -> 重量级锁
     *
     * 偏向锁：同步代码一直被一个线程访问，线程会自动获得锁
     * 轻量级锁：锁是偏向锁时，同步代码被其他线程访问，锁就会升级为轻量级锁，尝试获取锁的线程会通过自旋等待获取，不会阻塞，
     *          当自旋超过一定时间，或者这时又有一个线程尝试获得锁，就会升级为重量级锁
     * 重量级锁：此时所有等待的线程都会进入阻塞状态
     *
     * 其他锁相关概念
     *
     * 乐观 悲观：
     * 悲观锁认为在自己使用数据时别的线程一定会修改数据，因此需要先加锁，在java中synchronize和lock都是
     * 乐观锁认为使用数据时不会有别的线程来修改数据，在更新时判断有没有别的线程更新了数据
     *
     * 自旋 适应自旋：
     * 因为阻塞，唤醒一个线程会消耗cpu时间，而大部分持有锁的线程，锁定时间很短，因此会让尝试获得所得线程进行自旋，等待获取锁
     * 虽然避免了阻塞，但是会占用cpu，所以需设定自旋超过一定次数则阻塞（实现原理也是CAS）
     * 适应自旋是指自旋的次数由上一个在这个锁上自旋的次数决定，自旋成功的次数越多，则设定自旋的次数越多
     *
     * 公平 非公平：
     * 公平锁是指线程按申请锁的顺序获得锁，优点，等待队列中的线程不会饿死，缺点是cpu需要唤醒阻塞线程的开销比较大
     * 非公平是指在线程尝试获得锁时，会直接尝试，失败了才会进入等待队列，优点减少cpu唤醒线程的时间，缺点，等待队列中的线程，可能饿死
     *
     * 可重入 非可重入
     * 可重入是指线程在外层方法获取锁后，在内层方法自动获取锁，非可重入则是不能获取，可重入可以防止死锁
     *
     * 共享 排他
     * 共享锁可以被多个线程持有，持有的线程只能读数据，不能写，
     * 排他锁只能被一个线程持有，可以读可以写
     *
     * Reentrantlock synchronize都是可重入， 前者默认非公平，
     */
}