public class Main {
    /**
     * 原子性
     * 线程中执行的最小单元，不可中断，不可分割的操作
     * 基本类型的赋值中除long double外，其他都可以保证原子性
     *
     * volatile
     * 可以保证被修饰变量的可见性，以及有序性
     *
     * volatile修饰的变量要求在工作内存中，每次使用这个值之前先从主内存刷新到工作内存，保证每次获得的值是最新值
     *                     并保证在修改这个变量后，会立刻刷回到主内存，保证对其他线程可见
     * read load use assign store write
     * volatile可以保证可见性，但不能保证原子性
     * 只能修饰不依赖自身的变量 如boolean
     * 不能修饰自家类 i++ 因为 这一操作并不是原子的，先读取i，赋值加一，在写入i，在读取i时可能有别的线程也在读取，而此时获得的就是最新值
     *
     * 有序性
     * 保证了程序是按代码顺序运行的，比如 if (instance != null) {
     *     return instance;
     * }
     *  1.分配对象空间
     *  2，初始化对象
     *  3，instance指向对象空间
     *  2，3是依赖于1，但2，3，互不依赖，可能造成3先发生，这样在别的线程使用他时，就会出现错误
     *
     *
     *
     *
     * synchronized 同步
     * 1.确保线程互斥的访问同步的代码 2.保证共享变量的修改可以及时可见（数据直接刷新到主存） 3.解决重排序，
     * 保证获得锁的线程的操作先于之后获得
     * 实现方法
     * 1.修饰普通方法 锁为调用此方法的对象
     * 2.修饰代码块 锁synchronized（）参数里的对象
     * 3.修饰静态方法 锁为类锁，针对一切此类的实例
     *
     * 原理
     * 会在同步快的前后加入两条字节码，一个monitorenter 一个monitorexit
     * 会锁住一个对象，每次执行monitorenter时会将锁计数器加1，同样的执行monitorexit时会将锁减1，0的时候释放锁
     *
     * 偏向锁，轻量级锁，重量级锁
     * 偏向锁：在只有一个线程执行同步代码块时，不会释放这个锁，每次执行时不用重新获得，当出现竞争时才会释放，并升级成轻量级锁
     * 轻量锁：在轻量级锁时，认为在某一时刻，只有一个线程在竞争，他并不会阻塞，而是通过自旋，循环尝试获得这个锁
     * （线程挂起和恢复都需要从用户态转为内核态，这些操作给系统的并发性能带来了很大的压力）
     * 重量级锁：当同时多个线程竞争时，就会升级成重量级锁，此时其他竞争的线程就会阻塞
     *
     * 重量级锁是悲观锁：认为当一个线程执行代码块时，其他线程必定会修改
     * 乐观锁：认为当线程读数据时，其他线程不会修改
     *
     *
     * Lock
     * ReentrantLock ReentrantReadWriteLock
     * 可以实现读写锁
     *
     * synchronized与lock区别
     * synchronized 是java关键字，lock是java内的接口
     * 都是可重入锁
     * lock可以实现公平锁,synch不行
     * syn在发生异常时会自动释放锁,而lock不会,必须在finally中显示释放
     * syn在没有获取到锁时会发生阻塞,而lock可以立即返回,不会发生阻塞
     *
     *
     *
     *
     * yield()使当前运行的线程转为就绪状态
     * 当某个线程调用join（）方法时，可以使当前线程阻塞，先执行调用join的线程
     *
     *
     * 线程安全的实现方法
     * 临界区 互斥量 信号量
     */
}