# 方法和接口
### 方法
在以指针或者值为接受者的方法里，接收者既可以是指针也可以是值

而函数只能接受指定的参数

一般选用指针为接收者，一，是可以修改接收者指向的值，二，可以避免调用方法时复刻

```
package main

import "fmt"

type Vertex struct {
	X, Y float64
}

func (v *Vertex) Scale(f float64) {
	v.X = v.X * f
	v.Y = v.Y * f
}

func ScaleFunc(v *Vertex, f float64) {
	v.X = v.X * f
	v.Y = v.Y * f
}

func main() {
	v := Vertex{3, 4}
	v.Scale(2)
	ScaleFunc(&v, 10)

	p := &Vertex{4, 3}
	p.Scale(3)
	ScaleFunc(p, 8)

	fmt.Println(v, p)
}
```

### 接口

接口类型是一组方法签名的类型集合
```
type Abser interface {
    Abs() float64
    }
    
type MyFloat float64

func (m MyFloat) Abs() float64 {
    return -m
    }
```

接口值
```
type I interface {
    M()
    }

type T struct {
    S string
    }

func (t *T) M() {
    fmt.Println(t.S)
    }
    
func main() {
    var i I
    i = &T{"hello"}
    fmt.Println("(%v, %T)\n", i, i)
    }
```

得到的输出是
```
&{hello}, *main.T
```

类型断言
判断一个接口值是否保存了一个特定类型的值，用类型断言，返回两个值，一个是底层值，一个是断言是否成功的布尔值
```
package main

import "fmt"

func main() {
	var i interface{} = "hello"
	
	a, ok := i.(string)
	fmt.Println(a, ok)
}

```

类型选择
```
package main

import "fmt"

func do(i interface{}) {
	switch i.(type) {
	case int:
		fmt.Println("int")
	case string:
		fmt.Println("string")
	default:
		fmt.Println("default")
	}
}

func main() {
	do(20)
	do("hello")
}
```

### Stringer
可以用字符描述自己的类型
```
package main

import "fmt"

type IPAddr [4]byte

// TODO: 给 IPAddr 添加一个 "String() string" 方法
func (ip IPAddr) String() string {
	return fmt.Sprintf("%v.%v.%v.%v", ip[0], ip[1], ip[2], ip[3])
}

func main() {
	hosts := map[string]IPAddr{
		"loopback":  {127, 0, 0, 1},
		"googleDNS": {8, 8, 8, 8},
	}
	for name, ip := range hosts {
		fmt.Printf("%v: %v\n", name, ip)
	}
}
```

### 错误
通常函数会返回一个error值，调用的代码需要判断这个错误是否等于nil
```
package main

import (
	"fmt"
	"time"
)

type MyError struct {
	When time.Time
	What string
}

func (e *MyError) Error() string {
	return fmt.Sprintf("at %v, %s",
		e.When, e.What)
}

func run() error {
	return &MyError{
		time.Now(),
		"it didn't work",
	}
}

func main() {
	if err := run(); err != nil {
		fmt.Println(err)
	}
}
```
### Reader
```
package main

import "golang.org/x/tour/reader"

type MyReader struct{}

// TODO: 给 MyReader 添加一个 Read([]byte) (int, error) 方法
func (myReader MyReader) Read(b []byte) (int, error) {
	b[0] = 'A'
	return 1, nil
}

func main() {
	reader.Validate(MyReader{})
}
```
